"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const config_1 = __importDefault(require("config"));
const ora_1 = __importDefault(require("ora"));
const pluralize_1 = __importDefault(require("pluralize"));
const table_1 = require("table");
const analyzeOas_1 = __importStar(require("../../lib/analyzeOas"));
const baseCommand_1 = __importStar(require("../../lib/baseCommand"));
const logger_1 = require("../../lib/logger");
const prepareOas_1 = __importDefault(require("../../lib/prepareOas"));
const softError_1 = __importDefault(require("../../lib/softError"));
class OpenAPIInspectCommand extends baseCommand_1.default {
    constructor() {
        super();
        this.command = 'openapi:inspect';
        this.usage = 'openapi:inspect [file|url] [options]';
        this.description = 'Analyze an OpenAPI/Swagger definition for various OpenAPI and ReadMe feature usage.';
        this.cmdCategory = baseCommand_1.CommandCategories.APIS;
        this.hiddenArgs = ['spec'];
        this.args = [
            {
                name: 'spec',
                type: String,
                defaultOption: true,
            },
            this.getWorkingDirArg(),
            {
                name: 'feature',
                type: String,
                description: `A specific OpenAPI or ReadMe feature you wish to see detailed information on (if it exists). If any features supplied do not exist within the API definition an exit(1) code will be returned alongside the report.\n\nAvailable options: ${new Intl.ListFormat('en', { style: 'narrow' }).format((0, analyzeOas_1.getSupportedFeatures)())}`,
                multiple: true,
            },
        ];
        this.tableBorder = Object.entries((0, table_1.getBorderCharacters)('norc'))
            .map(([border, char]) => ({ [border]: chalk_1.default.gray(char) }))
            .reduce((prev, next) => Object.assign(prev, next));
    }
    getFeatureDocsURL(feature) {
        if (!feature.url) {
            return undefined;
        }
        if (typeof feature.url === 'object') {
            // We don't need to do any Swagger or Postman determination here because this command
            // always converts their spec to OpenAPI 3.0.
            if (this.definitionVersion.startsWith('3.0')) {
                return feature.url?.['3.0'] || 'This feature is not available on OpenAPI v3.0.';
            }
            else if (this.definitionVersion.startsWith('3.1')) {
                return feature.url?.['3.1'] || 'This feature is not available on OpenAPI v3.1.';
            }
            return '';
        }
        return feature.url;
    }
    // eslint-disable-next-line class-methods-use-this
    buildFeaturesReport(analysis, features) {
        let hasUnusedFeature = false;
        const report = [
            // Minor bit of padding between the top of our report and the "analyzing your spec" messaging.
            '',
        ];
        features.forEach(feature => {
            if (feature in analysis.openapi) {
                const info = analysis.openapi[feature];
                if (!info.present) {
                    // If our last report entry was an unused feature we should add an empty line in the
                    // report to give everything some room to breathe.
                    if (report.length && report[report.length - 1].length) {
                        report.push('');
                    }
                    report.push(`${feature}: You do not use this.`);
                    hasUnusedFeature = true;
                }
                else {
                    report.push('');
                    report.push(`${feature}:`);
                    report.push(...info.locations.map(loc => ` Â· ${chalk_1.default.yellow(loc)}`));
                }
            }
        });
        if (features.includes('readme')) {
            // Add some spacing between our OpenAPI and ReadMe extension reports (but only if our last
            // entry wasn't an empty line).
            if (features.length > 1 && report[report.length - 1].length) {
                report.push('');
            }
            Object.entries(analysis.readme).forEach(([feature, info]) => {
                if (!info.present) {
                    report.push(`${feature}: You do not use this.`);
                    hasUnusedFeature = true;
                }
                else {
                    report.push(`${feature}:`);
                    report.push(...info.locations.map(loc => ` Â· ${chalk_1.default.yellow(loc)}`));
                    report.push('');
                }
            });
        }
        // Because we add a little bit of padding between our report and the "analyzing your spec" copy
        // if this second entry in the report is an empty line then we can safely remove it so we don't
        // end up with multiple empty lines at the top of our report.
        if (!report[1].length) {
            report.splice(0, 1);
        }
        // If the last entry in our report array is an empty string then we should remove it.
        if (!report[report.length - 1].length) {
            report.pop();
        }
        return {
            report: report.join('\n'),
            hasUnusedFeature,
        };
    }
    buildFullReport(analysis) {
        const report = ['Here are some interesting things we found in your API definition. ðŸ•µï¸', ''];
        // General API definition statistics
        Object.entries(analysis.general).forEach(([, info]) => {
            let msg;
            if (Array.isArray(info.found)) {
                if (!info.found.length) {
                    return;
                }
                const highlightedData = info.found.map(d => chalk_1.default.yellow(d));
                if (info.found.length > 1) {
                    msg = `You are using ${chalk_1.default.bold(info.found.length)} ${(0, pluralize_1.default)(info.name, info.found.length)} throughout your API: ${new Intl.ListFormat('en').format(highlightedData)}`;
                }
                else {
                    msg = `You are using a single ${info.name} throughout your API: ${highlightedData[0]}`;
                }
            }
            else if (info.found > 1) {
                msg = `You have a total of ${chalk_1.default.bold(info.found)} ${(0, pluralize_1.default)(info.name, info.found)} in your API.`;
                if (info.found > 100) {
                    msg += ' Wow!';
                }
            }
            else {
                msg = `You have a single ${info.name} in your API.`;
            }
            report.push(` Â· ${msg}`);
        });
        // Build out a view of all OpenAPI and ReadMe features that we discovered.
        [
            { component: 'openapi', header: 'OpenAPI Features' },
            { component: 'readme', header: 'ReadMe-Specific Features and Extensions' },
        ].forEach(({ component, header }) => {
            const tableData = [
                [chalk_1.default.bold.green('Feature'), chalk_1.default.bold.green('Used?'), chalk_1.default.bold.green('Description')],
            ];
            Object.entries(analysis[component]).forEach(([feature, info]) => {
                const descriptions = [];
                if (info.description) {
                    descriptions.push(info.description);
                }
                const url = this.getFeatureDocsURL(info);
                if (url) {
                    descriptions.push(chalk_1.default.grey(url));
                }
                tableData.push([feature, info.present ? 'âœ…' : '', descriptions.join('\n\n')]);
            });
            report.push('');
            report.push(header);
            report.push((0, table_1.table)(tableData, {
                border: this.tableBorder,
                columns: {
                    2: {
                        width: 80,
                        wrapWord: true,
                    },
                },
            }));
        });
        return report.join('\n');
    }
    async run(opts) {
        await super.run(opts);
        const { spec, workingDirectory, feature: features } = opts;
        // If we have features we should validate that they're supported.
        if (features?.length) {
            const invalidFeatures = features.filter(feature => !(0, analyzeOas_1.getSupportedFeatures)().includes(feature));
            if (invalidFeatures.length) {
                return Promise.reject(new Error(`Unknown features: ${invalidFeatures.join(', ')}. See \`${config_1.default.get('cli')} help ${this.command}\` for help.`));
            }
        }
        if (workingDirectory) {
            const previousWorkingDirectory = process.cwd();
            process.chdir(workingDirectory);
            baseCommand_1.default.debug(`switching working directory from ${previousWorkingDirectory} to ${process.cwd()}`);
        }
        const { preparedSpec, definitionVersion } = await (0, prepareOas_1.default)(spec, 'openapi:inspect', { convertToLatest: true });
        this.definitionVersion = definitionVersion.version;
        const parsedPreparedSpec = JSON.parse(preparedSpec);
        const spinner = (0, ora_1.default)({ ...(0, logger_1.oraOptions)() });
        if (features?.length) {
            spinner.start(`Analyzing your API definition for usage of ${new Intl.ListFormat('en').format(features.map(feature => (feature === 'readme' ? 'ReadMe extensions' : feature)))}...`);
        }
        else {
            spinner.start('Analyzing your API definition for OpenAPI and ReadMe feature usage...');
        }
        const analysis = await (0, analyzeOas_1.default)(parsedPreparedSpec).catch(err => {
            baseCommand_1.default.debug(`analyzer err: ${err.message}`);
            spinner.fail();
            throw err;
        });
        if (features?.length) {
            spinner.succeed(`${spinner.text} done! âœ…`);
            const { report, hasUnusedFeature } = this.buildFeaturesReport(analysis, features);
            if (hasUnusedFeature) {
                // If we have any unused features we should reject the command with a soft error so we
                // output the report as normal but return a `exit(1)` status code.
                return Promise.reject(new softError_1.default(report));
            }
            return Promise.resolve(report);
        }
        spinner.stop();
        return Promise.resolve(this.buildFullReport(analysis));
    }
}
exports.default = OpenAPIInspectCommand;
