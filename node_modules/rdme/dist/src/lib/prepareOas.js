"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const oas_normalize_1 = __importStar(require("oas-normalize"));
const ora_1 = __importDefault(require("ora"));
const isCI_1 = __importDefault(require("./isCI"));
const logger_1 = require("./logger");
const promptWrapper_1 = __importDefault(require("./promptWrapper"));
const readdirRecursive_1 = __importDefault(require("./readdirRecursive"));
const capitalizeSpecType = (type) => type === 'openapi' ? 'OpenAPI' : type.charAt(0).toUpperCase() + type.slice(1);
/**
 * Normalizes, validates, and (optionally) bundles an OpenAPI definition.
 *
 * @param path Path to a spec file. If this is missing, the current directory is searched for
 *    certain file names.
 * @param command The command context in which this is being run within (uploading a spec,
 *    validation, or reducing one).
 */
async function prepareOas(path, command, opts = {
    convertToLatest: false,
}) {
    let specPath = path;
    if (!specPath) {
        /**
         * Scans working directory for a potential OpenAPI or Swagger file.
         * Any files in the `.git` directory or defined in a top-level `.gitignore` file
         * are skipped.
         *
         * A "potential OpenAPI or Swagger file" is defined as a YAML or JSON file
         * that has an `openapi` or `swagger` property defined at the top-level.
         *
         * If multiple potential files are found, the user must select a single file.
         *
         * An error is thrown in the following cases:
         * - if in a CI environment and multiple files are found
         * - no files are found
         */
        const fileFindingSpinner = (0, ora_1.default)({ text: 'Looking for API definitions...', ...(0, logger_1.oraOptions)() }).start();
        let action;
        switch (command) {
            case 'openapi':
                action = 'upload';
                break;
            default:
                action = command.split(':')[1];
        }
        const jsonAndYamlFiles = (0, readdirRecursive_1.default)('.', true).filter(file => file.toLowerCase().endsWith('.json') ||
            file.toLowerCase().endsWith('.yaml') ||
            file.toLowerCase().endsWith('.yml'));
        (0, logger_1.debug)(`number of JSON or YAML files found: ${jsonAndYamlFiles.length}`);
        const possibleSpecFiles = (await Promise.all(jsonAndYamlFiles.map(file => {
            (0, logger_1.debug)(`attempting to oas-normalize ${file}`);
            const oas = new oas_normalize_1.default(file, { enablePaths: true });
            return oas
                .version()
                .then(({ specification, version }) => {
                (0, logger_1.debug)(`specification type for ${file}: ${specification}`);
                (0, logger_1.debug)(`version for ${file}: ${version}`);
                return ['openapi', 'swagger', 'postman'].includes(specification)
                    ? { filePath: file, specType: capitalizeSpecType(specification), version }
                    : null;
            })
                .catch(e => {
                (0, logger_1.debug)(`error extracting API definition specification version for ${file}: ${e.message}`);
                return null;
            });
        }))).filter(Boolean);
        (0, logger_1.debug)(`number of possible OpenAPI/Swagger files found: ${possibleSpecFiles.length}`);
        if (!possibleSpecFiles.length) {
            fileFindingSpinner.fail();
            throw new Error(`We couldn't find an OpenAPI or Swagger definition.\n\nPlease specify the path to your definition with \`rdme ${command} ./path/to/api/definition\`.`);
        }
        specPath = possibleSpecFiles[0].filePath;
        if (possibleSpecFiles.length === 1) {
            fileFindingSpinner.stop();
            (0, logger_1.info)(chalk_1.default.yellow(`We found ${specPath} and are attempting to ${action} it.`));
        }
        else if (possibleSpecFiles.length > 1) {
            if ((0, isCI_1.default)()) {
                fileFindingSpinner.fail();
                throw new Error('Multiple API definitions found in current directory. Please specify file.');
            }
            fileFindingSpinner.stop();
            const selection = await (0, promptWrapper_1.default)({
                name: 'file',
                message: `Multiple potential API definitions found! Which one would you like to ${action}?`,
                type: 'select',
                choices: possibleSpecFiles.map(file => ({
                    title: file.filePath,
                    value: file.filePath,
                    description: `${file.specType} ${file.version}`,
                })),
            });
            specPath = selection.file;
        }
    }
    const spinner = (0, ora_1.default)({ text: `Validating the API definition located at ${specPath}...`, ...(0, logger_1.oraOptions)() }).start();
    (0, logger_1.debug)(`about to normalize spec located at ${specPath}`);
    const oas = new oas_normalize_1.default(specPath, { colorizeErrors: true, enablePaths: true });
    (0, logger_1.debug)('spec normalized');
    // We're retrieving the original specification type here instead of after validation because if
    // they give us a Postman collection we should tell them that we handled a Postman collection, not
    // an OpenAPI definition (eventhough we'll actually convert it to OpenAPI under the hood).
    //
    // And though `.validate()` will run `.load()` itself running `.load()` here will not have any
    // performance implications as `oas-normalizes` caches the result of `.load()` the first time you
    // run it.
    const { specType, definitionVersion } = await oas.load().then(async (schema) => {
        const type = (0, oas_normalize_1.getAPIDefinitionType)(schema);
        return {
            specType: capitalizeSpecType(type),
            definitionVersion: await oas.version(),
        };
    });
    // If we were supplied a Postman collection this will **always** convert it to OpenAPI 3.0.
    let api = await oas.validate({ convertToLatest: opts.convertToLatest }).catch((err) => {
        spinner.fail();
        (0, logger_1.debug)(`raw validation error object: ${JSON.stringify(err)}`);
        throw err;
    });
    spinner.stop();
    (0, logger_1.debug)('ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ spec validated! logging spec below ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡');
    (0, logger_1.debug)(api);
    (0, logger_1.debug)('ğŸ‘†ğŸ‘†ğŸ‘†ğŸ‘†ğŸ‘† finished logging spec ğŸ‘†ğŸ‘†ğŸ‘†ğŸ‘†ğŸ‘†');
    (0, logger_1.debug)(`spec type: ${specType}`);
    if (opts.title) {
        (0, logger_1.debug)(`renaming title field to ${opts.title}`);
        api.info.title = opts.title;
    }
    const specFileType = oas.type;
    // No need to optional chain here since `info.version` is required to pass validation
    const specVersion = api.info.version;
    (0, logger_1.debug)(`version in spec: ${specVersion}`);
    if (['openapi', 'openapi:inspect', 'openapi:reduce'].includes(command)) {
        api = await oas.bundle();
        (0, logger_1.debug)('spec bundled');
    }
    return {
        preparedSpec: JSON.stringify(api),
        /** A string indicating whether the spec file is a local path, a URL, etc. */
        specFileType,
        /** The path/URL to the spec file */
        specPath,
        /** A string indicating whether the spec file is OpenAPI, Swagger, etc. */
        specType,
        /**
         * The `info.version` field, extracted from the normalized spec.
         * This is **not** the OpenAPI version (e.g., 3.1, 3.0),
         * this is a user input that we use to specify the version in ReadMe
         * (if they use the `useSpecVersion` flag)
         */
        specVersion,
        /**
         * This is the `openapi`, `swagger`, or `postman` specification version of their API definition.
         */
        definitionVersion,
    };
}
exports.default = prepareOas;
