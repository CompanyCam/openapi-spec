"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleRes = exports.getUserAgent = exports.cleanHeaders = void 0;
const path_1 = __importDefault(require("path"));
const config_1 = __importDefault(require("config"));
const mime_types_1 = __importDefault(require("mime-types"));
const node_fetch_1 = __importStar(require("node-fetch")); // eslint-disable-line no-restricted-imports
const package_json_1 = __importDefault(require("../../package.json"));
const apiError_1 = __importDefault(require("./apiError"));
const createGHA_1 = require("./createGHA");
const isCI_1 = __importStar(require("./isCI"));
const logger_1 = require("./logger");
const SUCCESS_NO_CONTENT = 204;
function getProxy() {
    // this is something of an industry standard env var, hence the checks for different casings
    const proxy = process.env.HTTPS_PROXY || process.env.https_proxy;
    if (proxy) {
        // adds trailing slash
        return proxy.endsWith('/') ? proxy : `${proxy}/`;
    }
    return '';
}
function stripQuotes(s) {
    if (!s)
        return '';
    return s.replace(/(^"|[",]*$)/g, '');
}
/**
 * Parses Warning header into an array of warning header objects
 * @param header raw `Warning` header
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Warning}
 * @see {@link https://www.rfc-editor.org/rfc/rfc7234#section-5.5}
 * @see {@link https://github.com/marcbachmann/warning-header-parser}
 */
function parseWarningHeader(header) {
    try {
        const warnings = header.split(/([0-9]{3} [a-z0-9.@\-/]*) /g);
        let previous;
        return warnings.reduce((all, w) => {
            // eslint-disable-next-line no-param-reassign
            w = w.trim();
            const newError = w.match(/^([0-9]{3}) (.*)/);
            if (newError) {
                previous = { code: newError[1], agent: newError[2], message: '' };
            }
            else if (w) {
                const errorContent = w.split(/" "/);
                if (errorContent) {
                    previous.message = stripQuotes(errorContent[0]);
                    previous.date = stripQuotes(errorContent[1]);
                    all.push(previous);
                }
            }
            return all;
        }, []);
    }
    catch (e) {
        (0, logger_1.debug)(`error parsing warning header: ${e.message}`);
        return [{ code: '199', agent: '-', message: header }];
    }
}
/**
 * Getter function for a string to be used in the user-agent header based on the current
 * environment.
 *
 */
function getUserAgent() {
    const gh = (0, isCI_1.isGHA)() ? '-github' : '';
    return `rdme${gh}/${package_json_1.default.version}`;
}
exports.getUserAgent = getUserAgent;
/**
 * Creates a relative path for the file from the root of the repo,
 * otherwise returns the path
 */
async function normalizeFilePath(opts) {
    if (opts.fileType === 'path') {
        const repoRoot = await createGHA_1.git.revparse(['--show-toplevel']).catch(e => {
            (0, logger_1.debug)(`[fetch] error grabbing git root: ${e.message}`);
            return '';
        });
        return path_1.default.relative(repoRoot, opts.filePath);
    }
    return opts.filePath;
}
/**
 * Sanitizes and stringifies the `Headers` object for logging purposes
 */
function sanitizeHeaders(headers) {
    const raw = new node_fetch_1.Headers(headers).raw();
    if (raw.Authorization)
        raw.Authorization = ['redacted'];
    return JSON.stringify(raw);
}
/**
 * Wrapper for the `fetch` API so we can add rdme-specific headers to all API requests.
 *
 * @param pathname the pathname to make the request to. Must have a leading slash.
 * @param fileOpts optional object containing information about the file being sent.
 * We use this to construct a full source URL for the file.
 */
async function readmeAPIFetch(pathname, options = { headers: new node_fetch_1.Headers() }, fileOpts = { filePath: '', fileType: false }) {
    let source = 'cli';
    let headers = options.headers;
    if (!(options.headers instanceof node_fetch_1.Headers)) {
        headers = new node_fetch_1.Headers(options.headers);
    }
    headers.set('User-Agent', getUserAgent());
    if ((0, isCI_1.isGHA)()) {
        source = 'cli-gh';
        headers.set('x-github-repository', process.env.GITHUB_REPOSITORY);
        headers.set('x-github-run-attempt', process.env.GITHUB_RUN_ATTEMPT);
        headers.set('x-github-run-id', process.env.GITHUB_RUN_ID);
        headers.set('x-github-run-number', process.env.GITHUB_RUN_NUMBER);
        headers.set('x-github-sha', process.env.GITHUB_SHA);
        const filePath = await normalizeFilePath(fileOpts);
        if (filePath) {
            /**
             * Constructs a full URL to the file using GitHub Actions runner variables
             * @see {@link https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables}
             * @example https://github.com/readmeio/rdme/blob/cb4129d5c7b51ff3b50f933a9c7d0c3d0d33d62c/documentation/rdme.md
             */
            try {
                const sourceUrl = new URL(`${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/blob/${process.env.GITHUB_SHA}/${filePath}`).href;
                headers.set('x-readme-source-url', sourceUrl);
            }
            catch (e) {
                (0, logger_1.debug)(`error constructing github source url: ${e.message}`);
            }
        }
    }
    if ((0, isCI_1.default)()) {
        headers.set('x-rdme-ci', (0, isCI_1.ciName)());
    }
    headers.set('x-readme-source', source);
    if (fileOpts.filePath && fileOpts.fileType === 'url') {
        headers.set('x-readme-source-url', fileOpts.filePath);
    }
    const fullUrl = `${getProxy()}${config_1.default.get('host')}${pathname}`;
    (0, logger_1.debug)(`making ${(options.method || 'get').toUpperCase()} request to ${fullUrl} with headers: ${sanitizeHeaders(headers)}`);
    return (0, node_fetch_1.default)(fullUrl, {
        ...options,
        headers,
    }).then(res => {
        const warningHeader = res.headers.get('Warning');
        if (warningHeader) {
            (0, logger_1.debug)(`received warning header: ${warningHeader}`);
            const warnings = parseWarningHeader(warningHeader);
            warnings.forEach(warning => {
                (0, logger_1.warn)(warning.message, 'ReadMe API Warning:');
            });
        }
        return res;
    });
}
exports.default = readmeAPIFetch;
/**
 * Small handler for handling responses from our API.
 *
 * If we receive JSON errors, we throw an APIError exception.
 *
 * If we receive non-JSON responses, we consider them errors and throw them.
 *
 * @param rejectOnJsonError if omitted (or set to true), the function will return
 * an `APIError` if the JSON body contains an `error` property. If set to false,
 * the function will return a resolved promise containing the JSON object.
 *
 */
async function handleRes(res, rejectOnJsonError = true) {
    const contentType = res.headers.get('content-type');
    const extension = mime_types_1.default.extension(contentType);
    if (extension === 'json') {
        const body = await res.json();
        (0, logger_1.debug)(`received status code ${res.status} from ${res.url} with JSON response: ${JSON.stringify(body)}`);
        if (body.error && rejectOnJsonError) {
            return Promise.reject(new apiError_1.default(body));
        }
        return body;
    }
    if (res.status === SUCCESS_NO_CONTENT) {
        (0, logger_1.debug)(`received status code ${res.status} from ${res.url} with no content`);
        return {};
    }
    // If we receive a non-JSON response, it's likely an error.
    // Let's debug the raw response body and throw it.
    const body = await res.text();
    (0, logger_1.debug)(`received status code ${res.status} from ${res.url} with non-JSON response: ${body}`);
    return Promise.reject(body);
}
exports.handleRes = handleRes;
/**
 * Returns the basic auth header and any other defined headers for use in `node-fetch` API calls.
 *
 */
function cleanHeaders(key, inputHeaders = new node_fetch_1.Headers()) {
    const encodedKey = Buffer.from(`${key}:`).toString('base64');
    const headers = new node_fetch_1.Headers({
        Authorization: `Basic ${encodedKey}`,
    });
    for (const header of inputHeaders.entries()) {
        // If you supply `undefined` or `null` to the `Headers` API it'll convert that those to a
        // string.
        if (header[1] !== 'null' && header[1] !== 'undefined' && header[1].length > 0) {
            headers.set(header[0], header[1]);
        }
    }
    return headers;
}
exports.cleanHeaders = cleanHeaders;
