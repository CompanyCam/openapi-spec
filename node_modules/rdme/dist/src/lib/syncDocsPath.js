"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const config_1 = __importDefault(require("config"));
const node_fetch_1 = require("node-fetch");
const apiError_1 = __importDefault(require("./apiError"));
const baseCommand_1 = __importStar(require("./baseCommand"));
const logger_1 = require("./logger");
const readdirRecursive_1 = __importDefault(require("./readdirRecursive"));
const readDoc_1 = __importDefault(require("./readDoc"));
const readmeAPIFetch_1 = __importStar(require("./readmeAPIFetch"));
/**
 * Reads the contents of the specified Markdown or HTML file
 * and creates/updates the corresponding doc in ReadMe
 *
 * @param key the project API key
 * @param selectedVersion the project version
 * @param dryRun boolean indicating dry run mode
 * @param filePath path to file
 * @param type module within ReadMe to update (e.g. docs, changelogs, etc.)
 * @returns A promise-wrapped string with the result
 */
async function pushDoc(key, selectedVersion, dryRun, filePath, type) {
    const { content, data, hash, slug } = (0, readDoc_1.default)(filePath);
    // TODO: ideally we should offer a zero-configuration approach that doesn't
    // require YAML front matter, but that will have to be a breaking change
    if (!Object.keys(data).length) {
        (0, logger_1.debug)(`No front matter attributes found for ${filePath}, not syncing`);
        return `â­ï¸  no front matter attributes found for ${filePath}, skipping`;
    }
    let payload = { body: content, ...data, lastUpdatedHash: hash };
    if (type === baseCommand_1.CommandCategories.CUSTOM_PAGES) {
        if (filePath.endsWith('.html')) {
            payload = { html: content, htmlmode: true, ...data, lastUpdatedHash: hash };
        }
        else {
            payload = { body: content, htmlmode: false, ...data, lastUpdatedHash: hash };
        }
    }
    function createDoc() {
        if (dryRun) {
            return `ðŸŽ­ dry run! This will create '${slug}' with contents from ${filePath} with the following metadata: ${JSON.stringify(data)}`;
        }
        return ((0, readmeAPIFetch_1.default)(`/api/v1/${type}`, {
            method: 'post',
            headers: (0, readmeAPIFetch_1.cleanHeaders)(key, new node_fetch_1.Headers({
                'x-readme-version': selectedVersion,
                'Content-Type': 'application/json',
            })),
            body: JSON.stringify({
                slug,
                ...payload,
            }),
        }, { filePath, fileType: 'path' })
            .then(readmeAPIFetch_1.handleRes)
            // eslint-disable-next-line no-underscore-dangle
            .then(res => `ðŸŒ± successfully created '${res.slug}' (ID: ${res._id}) with contents from ${filePath}`));
    }
    function updateDoc(existingDoc) {
        if (hash === existingDoc.lastUpdatedHash) {
            return `${dryRun ? 'ðŸŽ­ dry run! ' : ''}\`${slug}\` ${dryRun ? 'will not be' : 'was not'} updated because there were no changes.`;
        }
        if (dryRun) {
            return `ðŸŽ­ dry run! This will update '${slug}' with contents from ${filePath} with the following metadata: ${JSON.stringify(data)}`;
        }
        return (0, readmeAPIFetch_1.default)(`/api/v1/${type}/${slug}`, {
            method: 'put',
            headers: (0, readmeAPIFetch_1.cleanHeaders)(key, new node_fetch_1.Headers({
                'x-readme-version': selectedVersion,
                'Content-Type': 'application/json',
            })),
            body: JSON.stringify(payload),
        }, { filePath, fileType: 'path' })
            .then(readmeAPIFetch_1.handleRes)
            .then(res => `âœï¸ successfully updated '${res.slug}' with contents from ${filePath}`);
    }
    return (0, readmeAPIFetch_1.default)(`/api/v1/${type}/${slug}`, {
        method: 'get',
        headers: (0, readmeAPIFetch_1.cleanHeaders)(key, new node_fetch_1.Headers({
            'x-readme-version': selectedVersion,
            Accept: 'application/json',
        })),
    })
        .then(async (res) => {
        const body = await (0, readmeAPIFetch_1.handleRes)(res, false);
        if (!res.ok) {
            if (res.status !== 404)
                return Promise.reject(new apiError_1.default(body));
            (0, logger_1.debug)(`error retrieving data for ${slug}, creating doc`);
            return createDoc();
        }
        (0, logger_1.debug)(`data received for ${slug}, updating doc`);
        return updateDoc(body);
    })
        .catch(err => {
        // eslint-disable-next-line no-param-reassign
        err.message = `Error uploading ${chalk_1.default.underline(filePath)}:\n\n${err.message}`;
        throw err;
    });
}
/**
 * Takes a path (either to a directory of files or to a single file)
 * and syncs those (either via POST or PUT) to ReadMe.
 * @returns A promise-wrapped string with the results
 */
async function syncDocsPath(
/** Project API key */
key, 
/** ReadMe project version */
selectedVersion, 
/** module within ReadMe to update (e.g. docs, changelogs, etc.) */
cmdType, 
/** Example command usage, used in error message */
usage, 
/** Path input, can either be a directory or a single file */
pathInput, 
/** boolean indicating dry run mode */
dryRun, 
/** array of allowed file extensions */
allowedFileExtensions = ['.markdown', '.md']) {
    if (!pathInput) {
        return Promise.reject(new Error(`No path provided. Usage \`${config_1.default.get('cli')} ${usage}\`.`));
    }
    const stat = await promises_1.default.stat(pathInput).catch(err => {
        if (err.code === 'ENOENT') {
            throw new Error("Oops! We couldn't locate a file or directory at the path you provided.");
        }
        throw err;
    });
    let output;
    if (stat.isDirectory()) {
        // Filter out any files that don't match allowedFileExtensions
        const files = (0, readdirRecursive_1.default)(pathInput).filter(file => allowedFileExtensions.includes(path_1.default.extname(file).toLowerCase()));
        baseCommand_1.default.debug(`number of files: ${files.length}`);
        if (!files.length) {
            return Promise.reject(new Error(`The directory you provided (${pathInput}) doesn't contain any of the following required files: ${allowedFileExtensions.join(', ')}.`));
        }
        output = (await Promise.all(files.map(async (filename) => {
            return pushDoc(key, selectedVersion, dryRun, filename, cmdType);
        }))).join('\n');
    }
    else {
        const fileExtension = path_1.default.extname(pathInput).toLowerCase();
        if (!allowedFileExtensions.includes(fileExtension)) {
            return Promise.reject(new Error(`Invalid file extension (${fileExtension}). Must be one of the following: ${allowedFileExtensions.join(', ')}`));
        }
        output = await pushDoc(key, selectedVersion, dryRun, pathInput, cmdType);
    }
    return Promise.resolve(chalk_1.default.green(output));
}
exports.default = syncDocsPath;
