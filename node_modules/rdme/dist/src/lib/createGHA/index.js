"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGitData = exports.getGHAFileName = exports.git = exports.getConfigStoreKey = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const prompts_1 = __importDefault(require("prompts"));
const simple_git_1 = __importDefault(require("simple-git"));
const configstore_1 = __importDefault(require("../configstore"));
const getPkgVersion_1 = require("../getPkgVersion");
const isCI_1 = __importStar(require("../isCI"));
const logger_1 = require("../logger");
const promptWrapper_1 = __importDefault(require("../promptWrapper"));
const validatePromptInput_1 = require("../validatePromptInput");
const baseFile_1 = __importDefault(require("./baseFile"));
/**
 * Generates the key for storing info in `configstore` object.
 * @param repoRoot The root of the repo
 */
const getConfigStoreKey = (repoRoot) => `createGHA.${repoRoot}`;
exports.getConfigStoreKey = getConfigStoreKey;
/**
 * The directory where GitHub Actions workflow files are stored.
 *
 * This is the same across all repositories on GitHub.
 *
 * @see {@link https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#about-yaml-syntax-for-workflows}
 */
const GITHUB_WORKFLOW_DIR = '.github/workflows';
const GITHUB_SECRET_NAME = 'README_API_KEY';
exports.git = (0, simple_git_1.default)();
/**
 * Removes any non-file-friendly characters and adds
 * the full path + file extension for GitHub Workflow files.
 * @param fileName raw file name to clean up
 */
const getGHAFileName = (fileName) => {
    return path_1.default.join(GITHUB_WORKFLOW_DIR, `${(0, validatePromptInput_1.cleanFileName)(fileName).toLowerCase()}.yml`);
};
exports.getGHAFileName = getGHAFileName;
/**
 * Returns a redacted `key` if the current command uses authentication.
 * Otherwise, returns `false`.
 */
function getKey(args, opts) {
    if (args.some(arg => arg.name === 'key')) {
        return `â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢${opts.key.slice(-5)}`;
    }
    return false;
}
/**
 * Constructs the command string that we pass into the workflow file.
 */
function constructCmdString(command, args, opts) {
    const optsString = args
        .sort(arg => (arg.defaultOption ? -1 : 0))
        .map(arg => {
        const val = opts[arg.name];
        // if default option, return the value
        if (arg.defaultOption)
            return val;
        // obfuscate the key in a GitHub secret
        if (arg.name === 'key')
            return `--key=$\{{ secrets.${GITHUB_SECRET_NAME} }}`;
        // remove the GitHub flag
        if (arg.name === 'github')
            return false;
        // if a boolean value, return the flag
        if (arg.type === Boolean && val)
            return `--${arg.name}`;
        if (val)
            return `--${arg.name}=${val}`;
        return false;
    })
        .filter(Boolean)
        .join(' ');
    return `${command} ${optsString}`.trim();
}
/**
 * Function to return various git attributes needed for running GitHub Action
 */
async function getGitData() {
    // Expressions to search raw output of `git remote show origin`
    const headRegEx = /^ {2}HEAD branch: /g;
    const headLineRegEx = /^ {2}HEAD branch:.*/gm;
    const isRepo = await exports.git.checkIsRepo().catch(e => {
        (0, logger_1.debug)(`error running git repo check: ${e.message}`);
        return false;
    });
    (0, logger_1.debug)(`[getGitData] isRepo result: ${isRepo}`);
    let containsGitHubRemote;
    let defaultBranch;
    const rawRemotes = await exports.git.remote([]).catch(e => {
        (0, logger_1.debug)(`[getGitData] error grabbing git remotes: ${e.message}`);
        return '';
    });
    (0, logger_1.debug)(`[getGitData] rawRemotes result: ${rawRemotes}`);
    if (rawRemotes) {
        const remote = rawRemotes.split('\n')[0];
        (0, logger_1.debug)(`[getGitData] remote result: ${remote}`);
        const rawRemote = await exports.git.remote(['show', remote]).catch(e => {
            (0, logger_1.debug)(`[getGitData] error accessing remote: ${e.message}`);
            return '';
        });
        (0, logger_1.debug)(`[getGitData] rawRemote result: ${rawRemote}`);
        // Extract head branch from git output
        const rawHead = headLineRegEx.exec(rawRemote)?.[0];
        (0, logger_1.debug)(`[getGitData] rawHead result: ${rawHead}`);
        if (rawHead)
            defaultBranch = rawHead.replace(headRegEx, '');
        // Extract the word 'github' from git output
        const remotesList = (await exports.git.remote(['-v']));
        (0, logger_1.debug)(`[getGitData] remotesList result: ${remotesList}`);
        // This is a bit hairy but we want to keep it fairly general here
        // in case of GitHub Enterprise, etc.
        containsGitHubRemote = /github/.test(remotesList);
    }
    (0, logger_1.debug)(`[getGitData] containsGitHubRemote result: ${containsGitHubRemote}`);
    (0, logger_1.debug)(`[getGitData] defaultBranch result: ${defaultBranch}`);
    const repoRoot = await exports.git.revparse(['--show-toplevel']).catch(e => {
        (0, logger_1.debug)(`[getGitData] error grabbing git root: ${e.message}`);
        return '';
    });
    (0, logger_1.debug)(`[getGitData] repoRoot result: ${repoRoot}`);
    return { containsGitHubRemote, defaultBranch, isRepo, repoRoot };
}
exports.getGitData = getGitData;
/**
 * Post-command flow for creating a GitHub Actions workflow file.
 *
 */
async function createGHA(msg, command, args, opts) {
    (0, logger_1.debug)(`running GHA onboarding for ${command} command`);
    (0, logger_1.debug)(`opts used in createGHA: ${JSON.stringify(opts)}`);
    // if in a CI environment,
    // don't even bother running the git commands
    if (!opts.github && ((0, isCI_1.default)() || (0, isCI_1.isNpmScript)())) {
        (0, logger_1.debug)('not running GHA onboarding workflow in CI and/or npm script, exiting');
        return msg;
    }
    const { containsGitHubRemote, defaultBranch, isRepo, repoRoot } = await getGitData();
    const configVal = configstore_1.default.get((0, exports.getConfigStoreKey)(repoRoot));
    (0, logger_1.debug)(`repo value in config: ${configVal}`);
    const majorPkgVersion = await (0, getPkgVersion_1.getMajorPkgVersion)();
    (0, logger_1.debug)(`major pkg version: ${majorPkgVersion}`);
    if (!opts.github) {
        if (
        // not a repo
        !isRepo ||
            // user has previously declined to set up GHA for current repo and `rdme` package version
            configVal === majorPkgVersion ||
            // is a repo, but does not contain a GitHub remote
            (isRepo && !containsGitHubRemote) ||
            // not testing this function
            ((0, isCI_1.isTest)() && !process.env.TEST_RDME_CREATEGHA)) {
            (0, logger_1.debug)('not running GHA onboarding workflow, exiting');
            // We return the original command message and pretend this command flow never happened.
            return msg;
        }
    }
    if (msg)
        (0, logger_1.info)(msg, { includeEmojiPrefix: false });
    if (opts.github) {
        (0, logger_1.info)(chalk_1.default.bold("\nğŸš€ Let's get you set up with GitHub Actions! ğŸš€\n"), { includeEmojiPrefix: false });
    }
    else {
        (0, logger_1.info)([
            '',
            chalk_1.default.bold("ğŸ™ Looks like you're running this command in a GitHub Repository! ğŸ™"),
            '',
            `ğŸš€ With a few quick clicks, you can run this \`${command}\` command via GitHub Actions (${chalk_1.default.underline('https://github.com/features/actions')})`,
            '',
            `âœ¨ This means it will run ${chalk_1.default.italic('automagically')} with every push to a branch of your choice!`,
            '',
        ].join('\n'), { includeEmojiPrefix: false });
    }
    if (repoRoot) {
        const previousWorkingDirectory = process.cwd();
        process.chdir(repoRoot);
        (0, logger_1.debug)(`switching working directory from ${previousWorkingDirectory} to ${process.cwd()}`);
    }
    prompts_1.default.override({ shouldCreateGHA: opts.github });
    const { branch, filePath, shouldCreateGHA } = await (0, promptWrapper_1.default)([
        {
            message: 'Would you like to add a GitHub Actions workflow?',
            name: 'shouldCreateGHA',
            type: 'confirm',
            initial: true,
        },
        {
            message: 'What GitHub branch should this workflow run on?',
            name: 'branch',
            type: 'text',
            initial: defaultBranch || 'main',
        },
        {
            message: 'What would you like to name the GitHub Actions workflow file?',
            name: 'filePath',
            type: 'text',
            initial: (0, validatePromptInput_1.cleanFileName)(`rdme-${command}`),
            format: prev => (0, exports.getGHAFileName)(prev),
            validate: value => (0, validatePromptInput_1.validateFilePath)(value, exports.getGHAFileName),
        },
    ], {
        // @ts-expect-error answers is definitely an object,
        // despite TS insisting that it's an array.
        // link: https://github.com/terkelg/prompts#optionsonsubmit
        onSubmit: (p, a, answers) => !answers.shouldCreateGHA,
    });
    if (!shouldCreateGHA) {
        // if the user says no, we don't want to bug them again
        // for this repo and version of `rdme
        configstore_1.default.set((0, exports.getConfigStoreKey)(repoRoot), majorPkgVersion);
        throw new Error('GitHub Actions workflow creation cancelled. If you ever change your mind, you can run this command again with the `--github` flag.');
    }
    const data = {
        branch,
        cleanCommand: (0, validatePromptInput_1.cleanFileName)(command),
        command,
        commandString: constructCmdString(command, args, opts),
        rdmeVersion: `v${majorPkgVersion}`,
        timestamp: new Date().toISOString(),
    };
    (0, logger_1.debug)(`data for resolver: ${JSON.stringify(data)}`);
    let output = baseFile_1.default;
    Object.keys(data).forEach((key) => {
        output = output.replace(new RegExp(`{{${key}}}`, 'g'), data[key]);
    });
    if (!fs_1.default.existsSync(GITHUB_WORKFLOW_DIR)) {
        (0, logger_1.debug)('GHA workflow directory does not exist, creating');
        fs_1.default.mkdirSync(GITHUB_WORKFLOW_DIR, { recursive: true });
    }
    fs_1.default.writeFileSync(filePath, output);
    const success = [chalk_1.default.green('\nYour GitHub Actions workflow file has been created! âœ¨\n')];
    const key = getKey(args, opts);
    if (key) {
        success.push(chalk_1.default.bold('Almost done! Just a couple more steps:'), `1. Push your newly created file (${chalk_1.default.underline(filePath)}) to GitHub ğŸš€`, `2. Create a GitHub secret called ${chalk_1.default.bold(GITHUB_SECRET_NAME)} and populate the value with your ReadMe API key (${key}) ğŸ”‘`, '', `ğŸ” Check out GitHub's docs for more info on creating encrypted secrets (${chalk_1.default.underline('https://docs.github.com/actions/security-guides/encrypted-secrets#creating-encrypted-secrets-for-a-repository')})`);
    }
    else {
        success.push(`${chalk_1.default.bold('Almost done!')} Push your newly created file (${chalk_1.default.underline(filePath)}) to GitHub and you're all set ğŸš€`);
    }
    success.push('', `ğŸ¦‰ If you have any more questions, feel free to drop us a line! ${chalk_1.default.underline('support@readme.io')}`, '');
    return Promise.resolve(success.join('\n'));
}
exports.default = createGHA;
